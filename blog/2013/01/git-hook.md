---
title: "git hook: Не пускаем в репозиторий ошибки"
tags: "git,grunt,hook,Хочу сделать мир лучше"
date: "2013-01-02"
---

![](images/stop_errors.png "stop_errors")

Настраивая систему разворачивания проекта с репозитория, мы задумались над вопросом чистоты кода репозитория, ибо тесты на самом сервере - это хорошо, но в системе контроля версий также совсем не помешает держать рабочий код, особенно в "стабильной" ветке.

Как вариант решения:  сделать **git-hook**, который бы проверял каждый **push** на репозиторий и не давал заливать "плохой" код. (Под "плохой" мы будем понимать код, который не прошел юнит-тестов либо валидации JSHint)

О самом  [git hook](https://git-scm.com/book/ru/%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-Git-%D0%9F%D0%B5%D1%80%D0%B5%D1%85%D0%B2%D0%B0%D1%82%D1%87%D0%B8%D0%BA%D0%B8-%D0%B2-Git) можно почитать подробно на официальном сайте. Расскажу только некоторые детали реализации.

Все хуки лежат в директории **./git/hooks/**. Там же есть уже **готовые примеры** реализованные на shell-скрипте(с расширением _.sample_).

Список возможных действий, на которые можно повесить обработчик:

- applypatch-msg
- post-commit
- post-update
- pre-commit
- update
- commit-msg
- post-receive
- pre-applypatch
- pre-rebase

\- подробное описание можно посмотреть [тут](https://www.kernel.org/pub/software/scm/git/docs/githooks.html).

Все перехватчики(hooks) можно разделить по месту их выполнения на клиентские и серверные. В нашем случае мы можем проверять код как на стороне клиента перед отправкой, так и на стороне сервера после получения. В первом случае решение будет менее строгим, т.к. позволит разработчику отключить или изменить его в случае чего. Для этого создаем файл pre-commit, где будет описание действия нашего перехватчика.

Теперь стоит подумать как лучше реализовать код перехватчика. Сначала была мысль написать shell-скрипт, но потом мы вспомнили о [grunt](https://stepansuvorov.com/blog/2012/10/%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B0-javascript-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-grunt/), который уже прекрасно работал с проектом, и просто добавили еще одно задание(task) в него - _pre-commit-test_, в котором описали все необходимые проверки. Осталось только вызывать сборщик из hook-скрипта. Вот весь код:

#!/bin/sh

GRUNTJS\_DIR='/path\_to\_project/project\_dir'
GRUNT\_CMD=grunt
cd $GRUNTJS\_DIR
$GRUNT\_CMD pre-commit-test
EXIT\_CODE=$?
[ $EXIT\_CODE -gt 0 ] && echo && echo validation fail! && echo
exit $EXIT\_CODE

Немного комментариев:

GRUNT\_CMD=grunt

пусть к команде grunt(в случае, если она не глобальная)

[ $EXIT\_CODE -gt 0 ]

проверяем выдал ли что-то валидатор и в случае чего - прерываем выполнение.
