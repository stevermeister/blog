---
title: "Объектно ориентированный подход при работе с датой"
tags: "date,DateTime,php,Хочу сделать мир лучше"
date: "2012-09-02"
---

Все мы раньше так или иначе использовали в PHP функцию **date**() для произведения необходимых манипуляций с датой. Она прекрасна и решает множество задач, но увы иногда, когда очень хочется использовать объектный подход, она выпадает. Существует множество пользовательских решений, которые представляют классс-оболочку **Date** для функции **date**(), что решает вопрос. Но как мы знаем в **5.2** версии языка наконец-то сообразили сделать встроенный родной класс, и имя ему **DateTime**. В общем-то был добавлена целая группу классов работы с датой, но **DateTime** - основной, поэтому его мы и разберем.

Для тех кто работал с объектом Date на Javascript думаю будет проще перейти на DateTime. Начнем с начала - создадим объект:

$oDate = new DateTime;

можно как оставить конструктор без параметров, так и задать необходимое значение:

$oDate = new DateTime('2012-09-02 11:48:15');

тут есть особенность: есть мы хотим указать время через unixtime - то должны переди ставить значок "@":

$oDate = new DateTime('@1346586632');

Итак мы создали объект даты **$oDate** и теперь мы конечно захотим вывести его. Для этого есть специальный метод **format()**. Синтаксис аналогичен date():

echo $oDate->format('Y-m-d H:i:s');

Встроенного магического метода \_\_toString() почему-то не сделали, думаю можем сами расширить, если постоянно необходимо выводить один и тот же формат даты:

class CDateTime extends DateTime{
  function \_\_toString() {
    return $this->format('Y-m-d H:i:s');
  }
}

Тогда может будет просто вывести:

echo $oDate;

Что еще есть полезного в этом объекте? Еще есть 2 метода, которые позволяют удобно прибавлять и отнимать определенный временной промежуток:

$oDate->add(DateInterval::createFromDateString('10 days'));
$oDate->sub(DateInterval::createFromDateString('2 month'));

Вот таким способом мы прибавили 10 дней и отняли 2 месяца. Здесь стоит уделить внимание объекту нового для нас класса **DateInterval**, которые необходим для задания временного интервала. Создать мы его можем разными способами:

- через метод **createFromDateString**
- через параметр конструктора

Вот некое соответствие между ними:

параметр createFromDateString

параметр конструктора

1 day

P1D

2 weeks

P2W

3 months

P3M

4 years

P4Y

1 year + 1 day

P1Y1D

1 day + 12 hours

P1DT12H

3600 seconds

PT3600S

После создания данного объекта мы можем его менять обращаясь непосредственно к переменным:

$interval = DateInterval::createFromDateString('2 month');
$interval->h = 10; //задали значение часов

Очень интересно что вывод значения объекта осуществляется также через метод format(), [!Внимание] синтаксис для задания формата отличается от **DateTime**, и тут многие делают ошибку. Символы обозначения разрядов остались такие же(Y - год, m - месяц), но теперь перед каждым нужно добавлять значок "%":

echo $interval->format('%Y years %m months %d days %H hours ...');

Оставшиеся функции, которые могут быть интересны:

**DateTime::modify** ( string `$modify` ) - по синтаксису функции strtotime() **DateTime::diff** ( DateTime `$datetime2`) - вычисление расхождений дат

Также класс содержит константы необходимых форматов, например:

echo DateTime::W3C; //'Y-m-d\\TH:i:sP'

 

По основному все. Если кто-то знает еще какую либо полезную информацию о использовании объекта DateTime - пишите.
