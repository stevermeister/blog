---
title: "INSERT ... ON DUPLICATE KEY UPDATE"
tags: "mysql,sql,Хочу сделать мир лучше"
date: "2012-08-14"
---

![](images/mysql_update_on-300x266.png "mysql_update_on")

Недавно обнаружил для себя интересную альтернативу **Replace** в **MySQL**.

Суть: если у нас после добавления новой записи возникает дублирование( по первичному или уникальному ключу) - то мы обновляем старую запись, причем правило для обновления задаем сами. Появилось свойство еще в MySQL 4.1.0, но раньше как-то не обращал внимания.

Чтобы не уходить далеко от практики, разберем пример. Создадим таблицу:

CREATE TABLE \`test\` (
\`a\` INT,
\`b\` INT,
\`c\` INT,
PRIMARY KEY ( \`a\` )
)

Добавим одну запись в таблицу:

 ``` ``INSERT INTO `test` (`` ```\`a\` ,\`b\` ,\`c\``` `) VALUES (` ``1, 1, 1`);`

Попробуем добавить еще одну запись в таблицу с дублированием ключа:

 ``` ``INSERT INTO `test` (`` ```\`a\` ,\`b\` ,\`c\``` `) VALUES (` ``1, 2, 3`);`

Получим ошибку:

#1062 - Duplicate entry '1' for key 'PRIMARY'

и запись не будет добавлена.

А теперь мы хотим построить такой запрос, который при совпадении индекса обновит информацию в старой записи:

INSERT INTO test (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1;

В итоге получим таблицу:

a

b

c

1

1

2

Что для нас может быть интересно? что во второй части, а именно в **UPDATE** мы можем прописать не обязательно инкремент значения поля, а любые действия, которые захотим - как одно, так и несколько (через запятую).

INSERT INTO test (a,b,c) VALUES (1,2,3)
ON DUPLICATE KEY UPDATE a=300, b=300, c = a+b;
