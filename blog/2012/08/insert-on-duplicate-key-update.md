---
title: "INSERT ... ON DUPLICATE KEY UPDATE"
tags: "mysql,sql"
date: "2012-08-14"
---

![](images/mysql_update_on-300x266.png "mysql_update_on")

Недавно обнаружил для себя интересную альтернативу **Replace** в **MySQL**.

Суть: если у нас после добавления новой записи возникает дублирование( по первичному или уникальному ключу) - то мы обновляем старую запись, причем правило для обновления задаем сами. Появилось свойство еще в MySQL 4.1.0, но раньше как-то не обращал внимания.

Чтобы не уходить далеко от практики, разберем пример. Создадим таблицу:

```sql
CREATE TABLE `test` (
`a` INT,
`b` INT,
`c` INT,
PRIMARY KEY ( `a` )
)
```

Добавим одну запись в таблицу:

```sql
INSERT INTO `test` (`a` ,`b` ,`c`) VALUES (1, 1, 1);
```

Попробуем добавить еще одну запись в таблицу с дублированием ключа:

```sql
INSERT INTO `test` (`a` ,`b` ,`c`) VALUES (1, 2, 3);
```

Получим ошибку:

```sql
#1062 - Duplicate entry '1' for key 'PRIMARY'
```

и запись не будет добавлена.

А теперь мы хотим построить такой запрос, который при совпадении индекса обновит информацию в старой записи:

```sql
INSERT INTO `test` (`a`,`b`,`c`) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1;
```

В итоге получим таблицу:

| a | b | c |
|---|---|---|
| 1 | 1 | 2 | 


Что для нас может быть интересно? что во второй части, а именно в **UPDATE** мы можем прописать не обязательно инкремент значения поля, а любые действия, которые захотим - как одно, так и несколько (через запятую).

```sql
INSERT INTO `test` (`a`,`b`,`c`) VALUES (1,2,3) ON DUPLICATE KEY UPDATE a=300, b=300, c=a+b;
```